6/27/17

Problem: Need to pass in a callback to do a select when connecting to a redis backend.
This requires having access to all the other sockets, etc for anything that requires connection. This includes reconfiguration.

I suppose we can just pass in everything, and do abstractions later. Evidently I chose poor abstractions initially, and perhaps
it's just inherently integrated.
We can eventually package all resources together... if we didn't want to have any dynamic calls.
Perhaps that's fine. We have a finite number of calls, anyways, so we can easily just separate things into neat categories. Perhaps I was just too cute in trying to do a dynamic callback.



6/28/17
Need to actually send the correct server messages in the auth and db initial connection callbacks.
Let's think about redis cluster now, because it's a critical feature.

So we want to maintain a pool of connections. Perhaps we have a setting to configure the pool, initially?
Perhaps we can specify if a host is a cluster or not. If it is, then it will know to handle it.

7/1/17

I think we'll want to specify clusters, and have them be backends. That means there are two formats for a backend: cluster or host.

7/3/17

So I've decided to split Backend into handling two possible things: a single host/destination, or a redis cluster.
A redis cluster will need many hosts.

Of course, how do I handle shard failures in a redis cluster? I guess I'll just give the proper response?
What if I want to use multiple destinations, in case redis cluster is down..?

So there are a couple of situations here:
1. Using rustproxy as normal, simple hsots.
2. Defining a pool that maps to a redis cluster. When should a redis cluster be blacked out? It can be the same as 1.
3. Defining a pool that does sharding, that maps to multiple redis clusters, each of them is a shrd. Now we have two layers of blackout logic. The sharding done by rustproxy can be blacked out. And the sharding done by redis cluster can also be blacked out.
Rediscluster host => { hosts, weight, cluster_blackout?}

Concern:
Also, it seems the layout of the program is to have a registry of different connections. We need to make sure that they are still valid and don't leak.


12/4/17

Finally got some basic switch_config tests working! That concludes the major features required for a release.

Going to go over the codebase now and clean things up, including unrolling unwraps.